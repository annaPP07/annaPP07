1. Бинарная куча 
Определение:
Бинарная куча — это полное двоичное дерево, удовлетворяющее свойству кучи: для любой вершины её ключ не меньше (в max‑heap) или не больше (в min‑heap) ключей её потомков. Обычно реализуется на массиве, где для вершины с индексом i левый потомок имеет индекс 2i+1, правый — 2i+2, а родитель — ⌊(i−1)/2⌋.
Реализация по языкам
Python
Используется модуль heapq + список (внутреннее представление — массив).
Поддерживается только min‑heap; для max‑heap значения инвертируют.
Основные методы:
heappush(list, item) — вставка с сохранением свойства кучи;
heappop(list) — удаление и возврат минимального элемента.
C++
Реализуется через std::priority_queue или std::vector.
Операции:
push() — добавляет элемент в конец, затем «поднимает» его, восстанавливая свойство кучи;
pop() — удаляет корень, заменяет его последним элементом, затем «опускает» новый корень.
Java
Класс PriorityQueue (внутренний массив, доступ только через API).
Методы:
add(item) / offer(item) — вставка с восстановлением свойства кучи;
peek() — просмотр корня без удаления;
poll() — удаление корня и восстановление кучи («heapifying down»).

2. Биномиальная куча 
Определение:
Биномиальная куча — это набор биномиальных деревьев, каждое из которых удовлетворяет свойству кучи. Биномиальное дерево Bk порядка k имеет 2k
вершин, высоту k, и корень с k потомками, являющимися корнями биномиальных деревьев порядков k−1,k−2,…,0. Куча поддерживает эффективное объединение (O(logn)).
Реализация по языкам
Python
Нет встроенной реализации; создаётся вручную через классы BinomialNode и BinomialHeap.
Ключевые методы:
insert(key) — создаёт дерево степени 0;
getMin() — поиск минимума среди корней;
merge(heap1, heap2) — объединение списков корней с сортировкой по степеням.
C++
Отсутствует в STL; реализуется вручную.
Используются структуры BinomialHeap и BinomialNode.
Операции:
insert(int key) — создание узла;
extractMin() — удаление минимума, добавление его детей в список корней;
decreaseKey(BinomialNode* node, int new_key) — обновление ключа с подъёмом узла.
Java
Реализуется через классы BinomialHeapNode и BinomialHeap.
Управление памятью — через сборщик мусора.
Методы аналогичны C++: insert(), getMin(), extractMin(), merge(), decreaseKey().

3. Куча Фибоначчи 
Определение:
Куча Фибоначчи — это набор деревьев, удовлетворяющих свойству кучи, с отложенными операциями (например, объединение, уменьшение ключа). Ключевая особенность — амортизированная сложность операций: вставка O(1), извлечение минимума O(logn), уменьшение ключа O(1). Деревья не обязаны быть сбалансированными, что позволяет откладывать «работу» по поддержанию структуры.
Реализация по языкам
Python
Нет встроенной реализации; пишется вручную через классы FibonacciNode и FibonacciHeap.
Управление памятью — сборщик мусора Python.
C++
Реализуется через структуру Node и класс FibonacciHeap.
Ключевые методы:
unite(FibonacciHeap* heap) — слияние куч;
extractMin() — извлечение минимума;
decreaseKey(Element* x, T k) — уменьшение ключа.
Важная деталь: циклические ссылки left/right для упрощения операций.
Java
Реализуется классами FibonacciNode и FibonacciHeap.
Аналогичные методы: insert(), getMin(), extractMin(), decreaseKey().

4. Хэш‑таблица 
Определение:
Хэш‑таблица — это структура данных для хранения пар «ключ‑значение», использующая хэш‑функцию для преобразования ключа в индекс массива. Основные операции: вставка, поиск, удаление. При коллизиях применяются методы разрешения (цепочки, открытая адресация). Средняя сложность операций — O(1).
Реализация по языкам
Python
Встроенная реализация — словарь dict (оптимизированная хеш‑таблица).
Ручная реализация — через класс с массивом бакетов.
Методы: set(), get(), remove().
Ключи — только хэшируемые объекты (строки, числа, кортежи).
C++
Стандартная библиотека — std::unordered_map<K, V> (цепочечное хеширование).
Ручная реализация — массив связанных списков.
Основные операции:
table[key] = value — вставка/обновление;
table.find(key) — поиск;
table.erase(key) — удаление.
Поддерживает любые типы ключей/значений (при наличии hash и operator==).
Java
Классы:
Hashtable — потокобезопасная хеш‑таблица;
HashMap — несинхронизированная реализация (массив односвязных списков).
Основные методы:
put(key, value) — вставка;
get(key) — получение значения;
containsKey(key) — проверка наличия ключа;
remove(key) — удаление;
putAll(otherMap) — слияние с другой картой.

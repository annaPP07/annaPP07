Сортировка обменом (пузырьком)

def bubble_sort(arr):
    """
    Реализует алгоритм сортировки пузырьком.
    :param arr: список целых чисел
    :return: None (сортирует список на месте)
    """
    n = len(arr)                     # Определяем длину списка
    for i in range(n):               # Внешний цикл проходит по всем элементам списка
        swapped = False              # Флаг, позволяющий отслеживать наличие перестановок
        for j in range(0, n-i-1):    # Внутренний цикл проходит по списку, исключая уже упорядоченные элементы
            if arr[j] > arr[j+1]:   # Если текущий элемент больше следующего
                arr[j], arr[j+1] = arr[j+1], arr[j]  # Меняем их местами
                swapped = True       # Устанавливаем флаг, что произошла перестановка
        if not swapped:              # Если перестановок не было, значит массив уже отсортирован
            break                    # Прерываем выполнение внешнего цикла

# Пример использования
array = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", array)
bubble_sort(array)                  # Применяем сортировку
print("Отсортированный массив:", array)


Сортировка вставками

def insertion_sort(arr):
    """
    Реализует алгоритм сортировки вставками.
    :param arr: Список целочисленных элементов
    :return: None (сортирует список на месте)
    """
    n = len(arr)                          # Получаем длину входящего списка
    for i in range(1, n):                 # Начинаем обход списка с второго элемента
        key = arr[i]                      # Берём текущий элемент, который будем вставлять
        j = i - 1                         # Индекс предыдущего элемента
        while j >= 0 and arr[j] > key:    # Пока есть предыдущие элементы и они больше текущего ключа
            arr[j + 1] = arr[j]           # Сдвигаем больший элемент вправо
            j -= 1                        # Двигаясь назад по списку
        arr[j + 1] = key                  # Ставим ключ на его правильное место

# Пример использования
array = [12, 11, 13, 5, 6]
print("Исходный массив:", array)
insertion_sort(array)                     # Сортируем массив
print("Отсортированный массив:", array)


Сортировка Шелла 
def shell_sort(arr):
    """
    Реализует алгоритм сортировки Шелла.
    :param arr: Список целых чисел
    :return: Отсортированный список
    """
    gap = len(arr) // 2  # Начальное расстояние между элементами (шаг)

    # Продолжаем уменьшать шаг, пока он не достигнет нуля
    while gap > 0:
        # Просматриваем массив, начиная с элемента на расстоянии 'gap' от начала
        for i in range(gap, len(arr)):
            temp = arr[i]  # Сохраняем текущий элемент
            
            # Смещаем элементы, которые больше текущего, на 'gap' позиций вправо,
            # чтобы освободить место для вставки текущего элемента
            j = i
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]
                j -= gap
                
            # Вставляем текущий элемент на свободное место
            arr[j] = temp
        
        # Уменьшаем шаг в два раза для следующей итерации
        gap //= 2

# Пример использования
array = [64, 34, 25, 12, 22, 11, 90]
shell_sort(array)
print("Отсортированный массив:", array)

Быстрая сортировка 
def quicksort(arr):
    """
    Реализует алгоритм быстрой сортировки (quicksort).
    :param arr: Входной список
    :return: Отсортированный список
    """
    if len(arr) <= 1:                       # Базовый случай: пустой или одинарный список уже отсортированы
        return arr
    pivot = arr[len(arr) // 2]              # Выбор опорного элемента (pivot), здесь берём средний элемент
    left = [x for x in arr if x < pivot]    # Все элементы, меньшие pivot, отправляются влево
    middle = [x for x in arr if x == pivot] # Элементы, равные pivot, собираются посередине
    right = [x for x in arr if x > pivot]   # Большие элементы отправляем вправо
    return quicksort(left) + middle + quicksort(right)  # Рекурсивно сортируем левую и правую части
                                                      # и соединяем результаты

# Пример использования
array = [12, 4, 5, 6, 7, 3, 1, 15]
sorted_array = quicksort(array)
print(sorted_array)


Последовательный (линейный) поиск
def linear_search(arr, target):
    """
    Линейный поиск в списке.
    :param arr: список, в котором ведётся поиск
    :param target: искомый элемент
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    # Перебираем элементы списка по порядку
    for index in range(len(arr)):  # пробегаем по всем индексам массива
        if arr[index] == target:    # если текущий элемент равен искомому
            return index            # возвращаем индекс найденного элемента
    return -1                      # если элемент не найден, возвращаем -1


# Пример использования
my_list = [4, 2, 7, 1, 9, 3]
target_value = 7

result = linear_search(my_list, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на позиции {result}.")
else:
    print(f"Элемент {target_value} не найден.")

Поиск по Фибоначчи

def fibonacci_search(arr, target):
    """
    Реализует алгоритм поиска по Фибоначчи.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    # Генерируем последовательность чисел Фибоначчи, пока последнее число не станет больше или равно размеру массива
    fib_M_minus_2 = 0  # F(k-2)
    fib_M_minus_1 = 1  # F(k-1)
    fib_M = fib_M_minus_1 + fib_M_minus_2  # F(k)

    while fib_M < len(arr):
        fib_M_minus_2 = fib_M_minus_1
        fib_M_minus_1 = fib_M
        fib_M = fib_M_minus_1 + fib_M_minus_2

    offset = -1  # Начальное смещение для поиска
    while fib_M > 1:
        # Вычисляем индекс, на который нужно посмотреть
        i = min(offset + fib_M_minus_2, len(arr) - 1)

        # Если элемент в индексе меньше цели, движемся вправо
        if arr[i] < target:
            fib_M = fib_M_minus_1
            fib_M_minus_1 = fib_M_minus_2
            fib_M_minus_2 = fib_M - fib_M_minus_1
            offset = i

        # Если элемент в индексе больше цели, движемся влево
        elif arr[i] > target:
            fib_M = fib_M_minus_2
            fib_M_minus_1 = fib_M_minus_1 - fib_M_minus_2
            fib_M_minus_2 = fib_M - fib_M_minus_1

        # Если элемент найден, возвращаем его индекс
        else:
            return i

    # Если остался единственный элемент для проверки
    if fib_M_minus_1 and arr[offset + 1] == target:
        return offset + 1

    # Если элемент не найден, возвращаем -1
    return -1

# Пример использования
arr = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
target = 85
result = fibonacci_search(arr, target)

if result != -1:
    print(f"Элемент {target} найден на позиции {result}")
else:
    print(f"Элемент {target} не найден в массиве")

АЛГОРИТМЫ СОРТИРОВКИ

Сортировка выбором
Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Алгоритм:
Шаг 1: Основной цикл внешней итерации
Основной цикл идет по всей длине массива, начиная с первого элемента и заканчивая последним (точнее, почти последним)
Шаг 2: Поиск минимального элемента
Для каждого элемента внутри основного цикла осуществляется внутренний цикл, который находит минимальный элемент среди ещё не обработанных частей массива
Шаг 3: Замена элементов
После того как найдем минимальный элемент, мы обмениваем его с текущим элементом
Временная сложность:  общее количество сравнений приблизительно равно сумме чисел от 1 до n-1, что асимптотически составляет n2/2 операций сравнения.
Следовательно, временная сложность алгоритма сортировки выбором равна: O(n2).

Сортировка обменом (пузырек)
Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколькораз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильномпорядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Алгоритм:
Подготовка данных.Мы начинаем с заданного списка чисел (array), например [64, 34, 25, 12, 22, 11, 90]. Наша цель — отсортировать этот список по возрастанию.
Главный цикл.В нашем коде главная логика содержится в функции bubble_sort()
Логика внутренней сортировки.Во внешнем цикле существует внутренний цикл:for j in range(0, len(arr)-i-1)
Сравнение и перестановка элементов.Каждый раз, когда внутренний цикл обнаруживает пару элементов, расположенных неправильно (левый элемент больше правого), они меняются местами
Оптимизация раннего выхода.Код включает дополнительную проверку:swapped = False
Временная сложность: 
Средняя и худшая ситуации: O(n2), где n — длина массива.
Лучшая ситуация (массив уже отсортирован): O(n).

Сортировка вставками
Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка,постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента иперемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Алгоритм:
Алгоритм сортировки вставками основывается на простой идее: он рассматривает список как состоящий из двух частей — отсортированной и неотсортированной. Первоначально первая часть состоит только из первого элемента, а остальная часть — это еще не отсортированные элементы. Затем алгоритм берет второй элемент и вставляет его в первую часть так, чтобы сохранить порядок сортировки. Далее процедура повторяется для третьего элемента, четвертого и так далее, пока все элементы не будут включены в отсортированную часть.
Временная сложность: 
Лучший случай (массив уже отсортирован): O(n) 
Средний и худший случаи: O(n2)

Сортировка слиянием
Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам,сортировке половин и их слиянии.
Алгоритм:
Алгоритм сортировки слиянием основан на принципе "разделяй и властвуй": он рекурсивно разбивает массив на маленькие подмассивы, а затем объединяет их обратно в отсортированное состояние.
Временная сложность: 
Сложность сортировки слиянием — O(nlogn), где n — количество элементов в массиве.
Пространственная сложность: O(n), так как создаются дополнительные временные массивы для разделения и слияния подмассивов.

Сортировка Шелла
Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Алгоритм:
Алгоритм сортировки Шелла — это модификация классической сортировки вставками, которая существенно повышает скорость сортировки за счёт предварительной группировки элементов на определённом расстоянии друг от друга, позволяя быстрее привести массив в частично упорядоченное состояние.
Временная сложность: 
Средняя и лучшая сложность:Используя оптимальный подбор последовательности шагов (например, gaps типа Марчинского-Седгвика), достигаемая временная сложность составляет примерно O(N 1.25).
Худшая сложность:Если выбрать плохую последовательность шагов (например, простое деление пополам), временная сложность может ухудшиться до O(N2).

Быстрая сортировка
Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Алгоритм:
Алгоритм быстрой сортировки основан на подходе "разделяй и властвуй". Он рекурсивно разбивает массив на две части вокруг выбранного опорного элемента (pivot), затем сортирует каждую часть отдельно, после чего собирает их обратно в отсортированный массив.
Временная сложность: 
Средняя и лучшая сложность: O(nlogn), где n — длина массива.
Худшая сложность: O(n2), но это случается крайне редко, если массив предварительно отсортирован или почти отсортирован. Использование рандомизации или других техник выбора опорного элемента сводит вероятность ухудшения производительности к минимуму.

Пирамидальная сортировка 
Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Шаги алгоритма:
Преобразовать массив в max-кучу.
Взять максимум (верхушку кучи) и отправить его в конец массива.
Исключить последний элемент из рассмотрения и восстановить max-кучу.
Повторять шаги 2 и 3, пока не останется один элемент.
Временная сложность: 
Средняя и худшая сложность: O(nlogn), где n — количество элементов в массиве.
Пространственная сложность: O(1), так как сортировка проводится на месте, без дополнительного пространства.

Последовательный поиск
Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
Алгоритм:
Шаг 1: Перебирается каждый элемент массива.
Шаг 2: Каждый элемент сравнивается с искомым значением.
Шаг 3: Если элемент совпадает с искомым, возвращаем его индекс.
Шаг 4: Если ничего не найдено, возвращаем специальный индикатор (-1), обозначающий, что элемент не присутствует в списке.
Временная сложность: 
Лучшая временная сложность: O(1) — если искомый элемент находится в самом начале списка.
Средняя и худшая временная сложность: O(n) — в среднем и в худшем случае придется просмотреть весь список, если элемент находится в конце или вовсе отсутствует.

Бинарный поиск
Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
Алгоритм:
Алгоритм бинарного поиска предназначен для поиска элемента в отсортированном массиве за короткое время. Он значительно эффективнее линейного поиска, так как на каждом шаге сужает диапазон поиска примерно вдвое.
Временная сложность: 
Лучшая временная сложность: O(1) — если искомый элемент находится прямо в центре массива.
Средняя и худшая временная сложность: O(logn) — так как на каждом шаге пространство поиска сокращается вдвое.

Интерполирующий поиск
Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Алгоритм:

Временная сложность: 

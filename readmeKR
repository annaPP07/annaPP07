Алгоритмы сортировки

Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов). 
n = len(arr)
2. Каждый элемент помещается в корзину согласно функции распределения.
max_value = max(arr)
    min_value = min(arr)
    interval = (max_value - min_value + 1) / n
3. Содержимое каждой корзины сортируется индивидуально.
   sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)
4. Корзины соединяются в порядке увеличения диапазона.
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.
Временная сложность:
Оптимальная: O(N) (при идеально равномерном распределении и малых количествах уникальных элементов).
Средняя: O(N⋅log(N)) (типичное поведение при нормальном распределении данных).
Худшая: теоретически может доходить до O(N2), если все элементы попадут в одну корзину.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
def find_max(arr, n):
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
def flip(arr, k):
    arr[:k + 1] = reversed(arr[:k + 1])
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, curr_size - 1)
4. Повторить процесс для оставшейся неотсортированной части массива.
Особенности:
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример
нестандартных методов сортировки.
Временная сложность:
O(N) — встречается редко, если массив случайно расположен идеально для быстрых переворотов.
O(N2) — типична для большинства вводных данных, так как каждый этап требует переворота и поиска максимума, оба шага требуют линейного времени.
O(N 2) — наблюдается, когда элементы расположены наименее благоприятным образом, приводящим к большому числу переворотов и сравнений.

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
2. Бусины располагаются на «стержнях» (как на абаке).
 beads_matrix = [[False]*len(arr) for _ in range(max_height)]
3. Под действием «гравитации» бусины падают вниз.
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
Временная сложность:
Общая временная сложность: O(N×M), где N — длина входного массива, а M — максимальное значение в этом массиве.
Формирование и заполнение матрицы (сетки): O(N×M).
Процесс "падения" бусинок и последующее считывание результата: O(N×M).

Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
Принцип работы:
1. Делится массив на блоки длины m=n.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.
Временная сложность:
Поиск скачками демонстрирует асимптотическую сложность O(n), что делает его предпочтительнее классического линейного поиска, особенно на больших объёмах данных. Несмотря на потерю эффективности по сравнению с бинарным поиском (
O(logn)), этот подход может оказаться полезным, когда важны компромиссные решения между простотой реализации и производительностью.

Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Принцип работы:
1. Проверяется первый элемент массива.
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск.
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.
Временная сложность:
Лучший случай: O(1) — если искомый элемент находится на первом месте.
Средний случай: O(logn) — при удачной организации массива, учитывая особенности экспоненциального расширения и последующего бинарного поиска.
Худший случай: O(logn) — алгоритм гарантированно завершится за логарифмическое время, даже если элемент находится ближе к концу массива.
Экспоненциальный поиск демонстрирует среднюю и худшую временную сложность O(logn), что делает его оптимальным выбором для больших массивов, где важна балансировка между затратами на исследование начальных областей и быстрым доступом к дальним частям массива.



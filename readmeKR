Алгоритмы сортировки

Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов).
2. Каждый элемент помещается в корзину согласно функции распределения.
3. Содержимое каждой корзины сортируется индивидуально.
4. Корзины соединяются в порядке увеличения диапазона.
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.
Временная сложность:
Оптимальная: O(N) (при идеально равномерном распределении и малых количествах уникальных элементов).
Средняя: O(N⋅log(N)) (типичное поведение при нормальном распределении данных).
Худшая: теоретически может доходить до O(N2), если все элементы попадут в одну корзину.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
4. Повторить процесс для оставшейся неотсортированной части массива.
Особенности:
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример
нестандартных методов сортировки.
Временная сложность:
Лучшая ситуация: O(N) — встречается редко, если массив случайно расположен идеально для быстрых переворотов.
Средняя ситуация: O(N2) — типична для большинства вводных данных, так как каждый этап требует переворота и поиска максимума, оба шага требуют линейного времени.
Худшая ситуация: O(N 2) — наблюдается, когда элементы расположены наименее благоприятным образом, приводящим к большому числу переворотов и сравнений.

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
2. Бусины располагаются на «стержнях» (как на абаке).
3. Под действием «гравитации» бусины падают вниз.
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
Временная сложность:
Общая временная сложность: O(N×M), где N — длина входного массива, а M — максимальное значение в этом массиве.
Формирование и заполнение матрицы (сетки): O(N×M).
Процесс "падения" бусинок и последующее считывание результата: O(N×M).

Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
Принцип работы:
1. Делится массив на блоки длины m=n.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.
Временная сложность:

Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Принцип работы:
1. Проверяется первый элемент массива.
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск.
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.
Временная сложность:

Тернарный поиск (Ternary Search)
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).
Принцип работы (для массива):
1. Делится диапазон индексов на три части.
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
массива, где может находиться искомое значение.
Особенности:
Сложность также O(log⁡n), но число сравнений на шаг выше, чем в двоичном поиске.
Помимо массивов, тернарный поиск часто используется для нахождения минимума или
максимума на унимодальных функциях.
Временная сложность:

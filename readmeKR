Алгоритмы сортировки

Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.
Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов). 
size = len(arr)
2. Каждый элемент помещается в корзину согласно функции распределения.
index_b = int((size * arr[i]) / (max_value + 1))
3. Содержимое каждой корзины сортируется индивидуально.
buckets_list[i] = sorted(buckets_list[i])
4. Корзины соединяются в порядке увеличения диапазона.
final_output += buckets_list[i]
Особенности:
Эффективна для равномерно распределённых числовых данных и может достигать линейной
асимптотики O(n), если размер корзин выбран удачно. Однако эффективность сильно падает
при неравномерном распределении данных.
Временная сложность:
Средняя временная сложность корзинной сортировки: O(n), однако худший случай равен O(n2) или O(nlogn) в зависимости от используемого метода внутренней сортировки.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива.
max_idx = find_max_index(arr, current_size)
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым.
flip(arr, max_idx + 1)
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце.
flip(arr, current_size)
4. Повторить процесс для оставшейся неотсортированной части массива.
current_size -= 1
Особенности:
Сложность алгоритма — O(n2). Он интересен теоретически и используется как пример
нестандартных методов сортировки.
Временная сложность:
Следовательно, итоговая временная сложность — O(N2). Этот алгоритм хорош своей простотой и наглядностью, однако менее эффективен, 
чем классические методы типа быстрой сортировки (O(NlogN)).

Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.
Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению.
for i in range(len(arr)):
    for j in range(arr[i]):
        beads[i][j] = True
2. Бусины располагаются на «стержнях» (как на абаке).
   beads = [[False]*max_val for _ in range(len(arr))]
3. Под действием «гравитации» бусины падают вниз.
for col in range(max_val):
    count = sum(row[col] for row in beads)
    for row in beads:
        row[col] = False
    for row in reversed(beads[:count]):
        row[col] = True
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив.
result = []
for row in beads:
    result.append(sum(row))
return result
Особенности:
Алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.
Временная сложность:
Пространственная сложность алгоритма — O(n∗m), где n — размер массива, а m — максимальная величина элемента.
Временная сложность также составляет O(n∗m), так как для каждого элемента массива приходится пройти максимум m шагов.

Поиск скачками (Jump Search)
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
Принцип работы:
1. Делится массив на блоки длины m=n.
step = int(math.sqrt(len(arr)))
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
while arr[min(step, len(arr)) - 1] < x:   
    prev = step   
    step += int(math.sqrt(len(arr)))
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.
for i in range(prev, min(step + 1, len(arr))):   
if arr[i] == x:       
return i
Особенности:
В среднем сложность поиска O(n).
Оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.
Временная сложность:
Алгоритм имеет среднюю временную сложность порядка O(sqrt(n)). Причина в следующем:
Грубое приближение требует около sqrt(n) операций.
Линейный поиск внутри выбранного диапазона также выполняется за примерно sqrt(n) операций.

Экспоненциальный поиск (Exponential Search)
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.
Принцип работы:
1. Проверяется первый элемент массива.
while bound < n and arr[bound] <= target:
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
bound *= 2
3. На найденном диапазоне выполняется бинарный поиск.
while left <= right:
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] > target:
        right = mid - 1
    else:
        left = mid + 1
Особенности:
Сложность O(log⁡n). Эффективен при поиске в очень больших отсортированных массивах с
неизвестным размером или частичным доступом.
Временная сложность:
общая временная сложность экспоненциального поиска равна O(log N).



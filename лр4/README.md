Дерево — иерархическая структура данных из узлов, где у каждого узла один родитель (кроме корня) и возможно несколько детей; корень не имеет родителя, листья не имеют детей, и такая модель используется, например, для файловых систем и оргструктур.
Граф — нелинейная структура из вершин и рёбер; формально граф задаётся как G=(U,E) где U — множество вершин, E — множество рёбер, причём ребро можно представить парой e=[x,y] графы бывают ориентированными/неориентированными и взвешенными/невзвешенными.

Реализация бинарных деревьев
Общая структура: Во всех трех языках (Python, Java, C++) используется одинаковая базовая структура узла, содержащая ключ и ссылки на левого и правого потомков.
 Python: Класс Node с полями key, left, right (отсутствующие потомки представлены как None). Класс Tree содержит корень (root). Операции поиска, вставки и удаления реализованы как рекурсивно, так и итеративно. Для операции удаления используется вспомогательная функция (например, find_min) для поиска минимального элемента в поддереве.
 Java: Внутренний статический класс Node с полями key, left, right. Класс Tree хранит ссылку на root. Вставка реализована через рекурсивный метод doInsert и итеративный спуск по дереву, с обработкой случаев пустого дерева и дубликатов ключей.
 C++: Структура TNode с указателями Left, Right. Рекомендуется инициализация через списки инициализации и использование nullptr. Класс TTree включает деструктор для рекурсивного освобождения памяти. Элегантное решение для нерекурсивной вставки достигается через использование указателя на указатель (TNode**).
Реализация графов
Алгоритм Дейкстры реализован на всех трех языках с использованием двух основных представлений графа: матрицы смежности и списка смежности с приоритетной очередью.
Python: Граф представлен в виде словаря словарей, где ключи — это вершины, а значения — словари соседей и весов рёбер. Для алгоритма Дейкстры используется модуль heapq в качестве приоритетной очереди. Изначально расстояния до всех вершин устанавливаются в бесконечность (inf), а затем обновляются (релаксируются) по мере извлечения вершин с минимальным текущим расстоянием из очереди.
Java: Рассмотрены два подхода:
Матрица смежности: Используются массивы visited и distance, а для выбора следующей вершины применяется вспомогательная функция для поиска минимума.
Список смежности: Граф представлен как массив ArrayList[], а для обхода используется PriorityQueue. При обработке вершины накапливается вес пути до неё (wsf).
C++: Граф моделируется с помощью вектора векторов структур (с полями destination и weight). Для приоритетной очереди применяется priority_queue с пользовательским компаратором, обеспечивающим извлечение вершины с минимальным расстоянием. Используются массивы distances и previous, которые позволяют не только вычислить стоимость кратчайшего пути, но и восстановить его.

Пошаговая работа алгоритма на python
Дан граф:
V={1,2,3,4,5},
E={(1,2),(1,3),(2,4),(2,5),(3,4)}.
Шаг 1. Начинаем с вершины 1:
stack = [1], visited = {}
извлекаем 1, добавляем в visited
соседи: 2, 3 → добавляем в стек: stack = [2, 3]
visited = {1}
Шаг 2. Обрабатываем вершину 3:
извлекаем 3, добавляем в visited
сосед: 4 → добавляем в стек: stack = [2, 4]
visited = {1, 3}
Шаг 3. Обрабатываем вершину 4:
извлекаем 4, добавляем в visited
соседи: 2, 3 (оба уже в visited)
stack = [2], visited = {1, 3, 4}
Шаг 4. Обрабатываем вершину 2:
извлекаем 2, добавляем в visited
соседи: 4, 5 → 4 уже в visited, добавляем 5: stack = [5]
visited = {1, 2, 3, 4}
Шаг 5. Обрабатываем вершину 5:
извлекаем 5, добавляем в visited
нет непосещённых соседей
stack = [], алгоритм завершён.
Порядок обхода (итеративный): 1→3→4→2→5.
Оценка временной сложности
Время: O(∣V∣+∣E∣), где ∣V∣ — число вершин, ∣E∣ — число рёбер.
Каждая вершина добавляется в очередь ровно один раз (O(∣V∣)), каждое ребро проверяется один раз (O(∣E∣)).

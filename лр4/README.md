Дерево — иерархическая структура данных из узлов, где у каждого узла один родитель (кроме корня) и возможно несколько детей; корень не имеет родителя, листья не имеют детей, и такая модель используется, например, для файловых систем и оргструктур.

Граф — нелинейная структура из вершин и рёбер; формально граф задаётся как G=(U,E) где U — множество вершин, E — множество рёбер, причём ребро можно представить парой e=[x,y] графы бывают ориентированными/неориентированными и взвешенными/невзвешенными.

**Реализация бинарных деревьев**
Общая структура: Во всех трех языках (Python, Java, C++) используется одинаковая базовая структура узла, содержащая ключ и ссылки на левого и правого потомков.
- Python: Класс Node с полями key, left, right (отсутствующие потомки представлены как None). Класс Tree содержит корень (root). Операции поиска, вставки и удаления реализованы как рекурсивно, так и итеративно. Для операции удаления используется вспомогательная функция (например, find_min) для поиска минимального элемента в поддереве.
- Java: Внутренний статический класс Node с полями key, left, right. Класс Tree хранит ссылку на root. Вставка реализована через рекурсивный метод doInsert и итеративный спуск по дереву, с обработкой случаев пустого дерева и дубликатов ключей.
- C++: Структура TNode с указателями Left, Right. Рекомендуется инициализация через списки инициализации и использование nullptr. Класс TTree включает деструктор для рекурсивного освобождения памяти. Элегантное решение для нерекурсивной вставки достигается через использование указателя на указатель (TNode**).
  
**Реализация графов**
Алгоритм Дейкстры реализован на всех трех языках с использованием двух основных представлений графа: матрицы смежности и списка смежности с приоритетной очередью.
- Python: Граф представлен в виде словаря словарей, где ключи — это вершины, а значения — словари соседей и весов рёбер. Для алгоритма Дейкстры используется модуль heapq в качестве приоритетной очереди. Изначально расстояния до всех вершин устанавливаются в бесконечность (inf), а затем обновляются (релаксируются) по мере извлечения вершин с минимальным текущим расстоянием из очереди.
- Java: Рассмотрены два подхода:
Матрица смежности: Используются массивы visited и distance, а для выбора следующей вершины применяется вспомогательная функция для поиска минимума.
Список смежности: Граф представлен как массив ArrayList[], а для обхода используется PriorityQueue. При обработке вершины накапливается вес пути до неё (wsf).
- C++: Граф моделируется с помощью вектора векторов структур (с полями destination и weight). Для приоритетной очереди применяется priority_queue с пользовательским компаратором, обеспечивающим извлечение вершины с минимальным расстоянием. Используются массивы distances и previous, которые позволяют не только вычислить стоимость кратчайшего пути, но и восстановить его.
**Реализация деревьев и графов на Python, Java и C++**
python
" Бинарное дерево
class TreeNode:
    def __init__(self, val=0):
        self.val = val
        self.left = None
        self.right = None

" Граф (список смежности)
class Graph:
    def __init__(self):
        self.adj_list = {}
    
    def add_edge(self, u, v):
        if u not in self.adj_list:
            self.adj_list[u] = []
        self.adj_list[u].append(v)
        
        # Для неориентированного графа добавляем обратное ребро
        if v not in self.adj_list:
            self.adj_list[v] = []
        self.adj_list[v].append(u)

Особенности: динамическая типизация, простота синтаксиса, встроенные структуры (словари, списки).
```java
// Бинарное дерево
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

// Граф (список смежности)
import java.util.*;

class Graph {
    private Map<Integer, List<Integer>> adjList = new HashMap<>();
    
    public void addEdge(int u, int v) {
        adjList.putIfAbsent(u, new ArrayList<>());
        adjList.get(u).add(v);
        
        // Для неориентированного графа
        adjList.putIfAbsent(v, new ArrayList<>());
        adjList.get(v).add(u);
    }
}
Особенности: строгая типизация, использование стандартных коллекций (HashMap, ArrayList), явное управление памятью.
```c++
// Бинарное дерево
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Граф (список смежности)
#include <unordered_map>
#include <vector>

class Graph {
    std::unordered_map<int, std::vector<int>> adjList;
public:
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // Для неориентированного графа
    }
};
Особенности: ручное управление памятью, высокая производительность, использование STL (unordered_map, vector).

Реализация на Python (итеративная)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]
    
    while stack:
        vertex = stack.pop()
        if vertex not in visited:
            visited.add(vertex)
            print(vertex)  # Обработка вершины
            
            # Добавляем соседей в стек (в обратном порядке для сохранения порядка обхода)
            for neighbor in reversed(graph.adj_list.get(vertex, [])):
                if neighbor not in visited:
                    stack.append(neighbor)

**Пошаговая работа алгоритма на python**
Дан граф:
V={1,2,3,4,5},
E={(1,2),(1,3),(2,4),(2,5),(3,4)}.

**Шаг 1. Начинаем с вершины 1:**
stack = [1], visited = {}
извлекаем 1, добавляем в visited
соседи: 2, 3 → добавляем в стек: stack = [2, 3]
visited = {1}

**Шаг 2. Обрабатываем вершину 3:**
извлекаем 3, добавляем в visited
сосед: 4 → добавляем в стек: stack = [2, 4]
visited = {1, 3}

**Шаг 3. Обрабатываем вершину 4:**
извлекаем 4, добавляем в visited
соседи: 2, 3 (оба уже в visited)
stack = [2], visited = {1, 3, 4}

**Шаг 4. Обрабатываем вершину 2:**
извлекаем 2, добавляем в visited
соседи: 4, 5 → 4 уже в visited, добавляем 5: stack = [5]
visited = {1, 2, 3, 4}

**Шаг 5. Обрабатываем вершину 5:**
извлекаем 5, добавляем в visited
нет непосещённых соседей
stack = [], алгоритм завершён.
Порядок обхода (итеративный): 1→3→4→2→5.


**Оценка временной сложности**
Время: O(∣V∣+∣E∣), где ∣V∣ — число вершин, ∣E∣ — число рёбер.
Каждая вершина добавляется в очередь ровно один раз (O(∣V∣)), каждое ребро проверяется один раз (O(∣E∣)).

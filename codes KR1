Блочная (корзинная) сортировка

def bucket_sort(arr):
    # Определяем максимальное значение в списке
    max_value = max(arr)
    
    # Количество корзин определяется числом элементов
    size = len(arr)
    
    # Создаем пустые корзины
    buckets_list = []
    for _ in range(size):
        buckets_list.append([])
        
    # Распределяем элементы по корзинам
    for i in range(len(arr)):
        index_b = int((size * arr[i]) / (max_value + 1))
        buckets_list[index_b].append(arr[i])
    
    # Сортируем каждую отдельную корзину (используем встроенную сортировку Python)
    for i in range(size):
        buckets_list[i] = sorted(buckets_list[i])
    
    # Объединяем отсортированные корзины
    final_output = []
    for i in range(size):
        final_output += buckets_list[i]
    
    return final_output


# Пример использования
if __name__ == "__main__":
    array_to_sort = [8, 2, 5, 3, 9, 1, 6, 7, 4]
    print("Исходный массив:", array_to_sort)
    sorted_array = bucket_sort(array_to_sort)
    print("Отсортированный массив:", sorted_array)

Исходный массив: [8, 2, 5, 3, 9, 1, 6, 7, 4]
Отсортированный массив: [1, 2, 3, 4, 5, 6, 7, 8, 9]

Блинная сортировка

def flip(arr, k):
    # Переворот первых k элементов массива arr
    left = 0
    right = k - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1

def find_max_index(arr, n):
    # Поиск индекса максимального элемента среди первых n элементов массива
    max_idx = 0
    for i in range(n):
        if arr[i] > arr[max_idx]:
            max_idx = i
    return max_idx

def pancake_sort(arr):
    # Основной алгоритм блинной сортировки
    current_size = len(arr)
    
    while current_size > 1:
        # Шаг 1: находим индекс максимального элемента
        max_idx = find_max_index(arr, current_size)
        
        # Если максимум находится не на последнем месте,
        # мы сначала поднимаем его вверх (переворот к началу),
        # потом опускаем на нужное место (переворот всего массива)
        if max_idx != current_size - 1:
            # Поднимаем максимум наверх
            flip(arr, max_idx + 1)
            
            # Опускаем максимум на правильное место
            flip(arr, current_size)
        
        # Уменьшаем рабочую область массива
        current_size -= 1

# Пример использования
arr = [3, 6, 2, 4, 5, 1]
print("Исходный массив:", arr)
pancake_sort(arr)
print("Отсортированный массив:", arr)

Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Сортировка бусинами (гравитационная)
def bead_sort(arr):
    # Получение максимальной величины среди элементов списка,
    # чтобы определить длину необходимых строк ("бусин")
    max_val = max(arr)
    
    # Создание матрицы с количеством строк равным длине arr
    # и количеством столбцов равным максимальному значению
    beads = [[False]*max_val for _ in range(len(arr))]
    
    # Заполнение матриц булеанов (True - бусинка присутствует, False - отсутствует)
    for i in range(len(arr)):
        # Первые arr[i] позиций в строке ставятся True (булевые бусинки),
        # остальные остаются False
        for j in range(arr[i]):
            beads[i][j] = True
            
    # Перемещение бусин вниз: теперь каждый столбец представляет собой отсортированный элемент
    for col in range(max_val):
        count = sum(row[col] for row in beads)
        
        # Обнуляем весь столбец
        for row in beads:
            row[col] = False
            
        # Возвращаем "бусины" назад, начиная снизу
        for row in reversed(beads[:count]):
            row[col] = True
            
    # Восстанавливаем исходный список из результата выравнивания бусин
    result = []
    for row in beads:
        result.append(sum(row))
    return result


# Пример использования
arr = [5, 3, 1, 8]
sorted_arr = bead_sort(arr)
print("Исходный массив:", arr)
print("Отсортированный массив:", sorted_arr)

Исходный массив: [5, 3, 1, 8]
Отсортированный массив: [1, 3, 5, 8]

поиск скачками
import math

def jump_search(arr, x):
    # Шаг прыжка определяется как квадратный корень из размера массива
    step = int(math.sqrt(len(arr)))
    
    # Ищем подходящий диапазон для дальнейшего детального поиска
    prev = 0
    while arr[min(step, len(arr)) - 1] < x:
        prev = step       # запоминаем предыдущую позицию
        step += int(math.sqrt(len(arr)))   # увеличиваем шаг дальше
        
        if prev >= len(arr):     # проверяем выход за пределы массива
            return -1           # возвращаем -1, если элемент не найден
            
    # Применяем линейный поиск в выбранном диапазоне
    for i in range(prev, min(step + 1, len(arr))):
        if arr[i] == x:
            return i      # Возвращаем индекс найденного элемента
            
    return -1            # Если элемент не найден


# Пример работы программы
arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
x = 55

result = jump_search(arr, x)
if result != -1:
    print(f'Элемент {x} найден на индексе {result}')
else:
    print('Элемент не найден')

Элемент 55 найден на индексе 10


экспоненциальный поиск
def exponential_search(arr, target):
    """
    Функция реализует экспоненциальный поиск элемента в отсортированном списке.
    
    :param arr: Отсортированный список элементов
    :param target: Искомое значение
    :return: Индекс элемента, если элемент найден, иначе None
    """
    if not arr or len(arr) == 0:
        return None  # Проверяем, что массив существует и не пуст
    
    n = len(arr)
    bound = 1  # Начальное значение границы поиска
    
    while bound < n and arr[bound] <= target:
        bound *= 2  # Удвоение индекса до достижения подходящего диапазона
        
    left = bound // 2  # Левая граница окна поиска
    right = min(bound, n - 1)  # Правая граница окна поиска
    
    # Выполняем бинарный поиск внутри полученного диапазона
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid  # Элемент найден!
        elif arr[mid] > target:
            right = mid - 1  # Продолжаем искать слева
        else:
            left = mid + 1   # Продолжаем искать справа
            
    return None  # Если элемент не найден


# Пример использования
arr = [1, 3, 5, 8, 10, 12, 15]
target_value = 10
result = exponential_search(arr, target_value)
if result is not None:
    print(f'Индекс элемента {target_value}: {result}')
else:
    print('Элемент не найден')

Индекс элемента 10: 4

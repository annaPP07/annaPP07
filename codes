Блочная (корзинная) сортировка

def bucket_sort(arr):
    # Если массив пуст или состоит всего из одного элемента,
    # значит он уже отсортирован
    if len(arr) <= 1:
        return arr
    
    # Определяем минимальное и максимальное значения в массиве
    min_val = min(arr)
    max_val = max(arr)
    
    # Вычисляем количество корзин исходя из размера массива
    num_buckets = len(arr)
    
    # Создаем список корзин (каждая корзина изначально пустая)
    buckets = [[] for _ in range(num_buckets)]
    
    # Рассчитываем диапазон каждого интервала корзины
    interval_range = (max_val - min_val + 1) / float(num_buckets)
    
    # Распределяем элементы по корзинам
    for value in arr:
        index = int((value - min_val) // interval_range)
        
        # Проверяем крайний случай, чтобы избежать выхода за границы индекса
        if index >= num_buckets:
            index -= 1
            
        # Добавляем значение в нужную корзину
        buckets[index].append(value)
    
    # Сортируем каждую корзину отдельно встроенной функцией sorted()
    sorted_arr = []
    for bucket in buckets:
        sorted_bucket = sorted(bucket)
        sorted_arr.extend(sorted_bucket)
    
    return sorted_arr


# Пример использования
if __name__ == "__main__":
    unsorted_array = [89, 45, 68, 90, 29, 34, 17]
    print("Исходный массив:", unsorted_array)
    sorted_array = bucket_sort(unsorted_array)
    print("Отсортированный массив:", sorted_array)

Исходный массив: [89, 45, 68, 90, 29, 34, 17]
Отсортированный массив: [17, 29, 34, 45, 68, 89, 90]

Блинная сортировка

def flip(arr, k):
    """
    Переворачивает первые k+1 элементов списка (аналогично переворачиванию верхней части стопки блинов).
    :param arr: Исходный список
    :param k: Индекс, по которому надо перевернуть элементы
    """
    start = 0
    while start < k:
        # Меняем местами первый и последний элементы области, уменьшаем область переворота
        arr[start], arr[k] = arr[k], arr[start]
        start += 1
        k -= 1

def find_max(arr, n):
    """
    Ищет индекс максимального элемента в первых n элементах списка.
    :param arr: Список чисел
    :param n: Сколько верхних элементов проверять
    :return: Индекс максимального элемента
    """
    idx_max = 0
    for i in range(n):
        if arr[i] > arr[idx_max]:
            idx_max = i
    return idx_max

def pancake_sort(arr):
    """
    Основная функция для блинной сортировки.
    :param arr: Неотсортированный список
    :return: Отсортированный список
    """
    curr_size = len(arr)
    while curr_size > 1:
        # Шаг 1: находим индекс самого большого элемента в текущих неотсортированных элементах
        idx_max = find_max(arr, curr_size)
        
        # Если наибольший элемент уже находится на своём месте, пропускаем перевороты
        if idx_max != curr_size - 1:
            # Шаг 2: переворачиваем верхнюю часть, чтобы максимальный элемент стал первым
            flip(arr, idx_max)
            
            # Шаг 3: переворачиваем первую половину стопки, чтобы максимальный элемент попал на своё место
            flip(arr, curr_size - 1)
        
        # Уменьшаем размер неотсортированного участка
        curr_size -= 1
    return arr

# Тестируем алгоритм
if __name__ == "__main__":
    arr = [3, 6, 2, 4, 5, 1]
    print("Исходный массив:", arr)
    sorted_arr = pancake_sort(arr)
    print("Отсортированный массив:", sorted_arr)

Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Сортировка бусинами (гравитационная)
def bead_sort(arr):
    """
    Гравитационная сортировка (алгоритм 'бусиной').
    Вход: массив положительных целых чисел.
    Выход: отсортированный массив.
    """
    # Получить максимальную высоту стека бусинок
    max_height = max(arr)
    
    # Создать матрицу представления столбцов (стеков) бусинок
    beads_matrix = [[False]*len(arr) for _ in range(max_height)]
    
    # Заполнить бусы в матрице
    for col_idx, height in enumerate(arr):
        for row_idx in range(height):
            beads_matrix[row_idx][col_idx] = True
    
    # Теперь реализуем "падение" бусинок вниз
    for row in beads_matrix:
        stable_count = sum(row)
        unstable_count = len(row) - stable_count
        row[:stable_count] = [True] * stable_count
        row[stable_count:] = [False] * unstable_count
    
    # Чтение результирующего отсортированного массива
    result = []
    for col_idx in range(len(arr)):
        count = sum(beads_matrix[row_idx][col_idx] for row_idx in range(max_height))
        result.append(count)
    
    return result

# Пример использования
if __name__ == "__main__":
    input_list = [5, 3, 1, 7, 4]
    sorted_list = bead_sort(input_list)
    print(f"Исходный массив: {input_list}")
    print(f"Отсортированный массив: {sorted_list}")

Исходный массив: [5, 3, 1, 7, 4]
Отсортированный массив: [7, 5, 4, 3, 1]

Поиск скачками

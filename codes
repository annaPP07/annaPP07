Блочная (корзинная) сортировка

def bucket_sort(arr):
    # Определяем максимальное значение в списке
    max_value = max(arr)
    
    # Количество корзин определяется числом элементов
    size = len(arr)
    
    # Создаем пустые корзины
    buckets_list = []
    for _ in range(size):
        buckets_list.append([])
        
    # Распределяем элементы по корзинам
    for i in range(len(arr)):
        index_b = int((size * arr[i]) / (max_value + 1))
        buckets_list[index_b].append(arr[i])
    
    # Сортируем каждую отдельную корзину (используем встроенную сортировку Python)
    for i in range(size):
        buckets_list[i] = sorted(buckets_list[i])
    
    # Объединяем отсортированные корзины
    final_output = []
    for i in range(size):
        final_output += buckets_list[i]
    
    return final_output


# Пример использования
if __name__ == "__main__":
    array_to_sort = [8, 2, 5, 3, 9, 1, 6, 7, 4]
    print("Исходный массив:", array_to_sort)
    sorted_array = bucket_sort(array_to_sort)
    print("Отсортированный массив:", sorted_array)

Исходный массив: [8, 2, 5, 3, 9, 1, 6, 7, 4]
Отсортированный массив: [1, 2, 3, 4, 5, 6, 7, 8, 9]

Блинная сортировка

def flip(arr, k):
    """
    Переворачивает первые k+1 элементов списка (аналогично переворачиванию верхней части стопки блинов).
    :param arr: Исходный список
    :param k: Индекс, по которому надо перевернуть элементы
    """
    start = 0
    while start < k:
        # Меняем местами первый и последний элементы области, уменьшаем область переворота
        arr[start], arr[k] = arr[k], arr[start]
        start += 1
        k -= 1

def find_max(arr, n):
    """
    Ищет индекс максимального элемента в первых n элементах списка.
    :param arr: Список чисел
    :param n: Сколько верхних элементов проверять
    :return: Индекс максимального элемента
    """
    idx_max = 0
    for i in range(n):
        if arr[i] > arr[idx_max]:
            idx_max = i
    return idx_max

def pancake_sort(arr):
    """
    Основная функция для блинной сортировки.
    :param arr: Неотсортированный список
    :return: Отсортированный список
    """
    curr_size = len(arr)
    while curr_size > 1:
        # Шаг 1: находим индекс самого большого элемента в текущих неотсортированных элементах
        idx_max = find_max(arr, curr_size)
        
        # Если наибольший элемент уже находится на своём месте, пропускаем перевороты
        if idx_max != curr_size - 1:
            # Шаг 2: переворачиваем верхнюю часть, чтобы максимальный элемент стал первым
            flip(arr, idx_max)
            
            # Шаг 3: переворачиваем первую половину стопки, чтобы максимальный элемент попал на своё место
            flip(arr, curr_size - 1)
        
        # Уменьшаем размер неотсортированного участка
        curr_size -= 1
    return arr

# Тестируем алгоритм
if __name__ == "__main__":
    arr = [3, 6, 2, 4, 5, 1]
    print("Исходный массив:", arr)
    sorted_arr = pancake_sort(arr)
    print("Отсортированный массив:", sorted_arr)

Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Сортировка бусинами (гравитационная)
def bead_sort(arr):
    """
    Гравитационная сортировка (алгоритм 'бусиной').
    Вход: массив положительных целых чисел.
    Выход: отсортированный массив.
    """
    # Получить максимальную высоту стека бусинок
    max_height = max(arr)
    
    # Создать матрицу представления столбцов (стеков) бусинок
    beads_matrix = [[False]*len(arr) for _ in range(max_height)]
    
    # Заполнить бусы в матрице
    for col_idx, height in enumerate(arr):
        for row_idx in range(height):
            beads_matrix[row_idx][col_idx] = True
    
    # Теперь реализуем "падение" бусинок вниз
    for row in beads_matrix:
        stable_count = sum(row)
        unstable_count = len(row) - stable_count
        row[:stable_count] = [True] * stable_count
        row[stable_count:] = [False] * unstable_count
    
    # Чтение результирующего отсортированного массива
    result = []
    for col_idx in range(len(arr)):
        count = sum(beads_matrix[row_idx][col_idx] for row_idx in range(max_height))
        result.append(count)
    
    return result

# Пример использования
if __name__ == "__main__":
    input_list = [5, 3, 1, 7, 4]
    sorted_list = bead_sort(input_list)
    print(f"Исходный массив: {input_list}")
    print(f"Отсортированный массив: {sorted_list}")

Исходный массив: [5, 3, 1, 7, 4]
Отсортированный массив: [7, 5, 4, 3, 1]

поиск скачками
import math

def jump_search(arr, target):
    """
    Алгоритм поиска скачками (Jump Search).
    Ввод: отсортированный массив и искомое значение.
    Вывод: индекс искомого элемента или -1, если элемент не найден.
    """
    n = len(arr)              # Длина массива
    step = int(math.sqrt(n))  # Шаг поиска (квадратный корень из длины массива)
    
    # 1-й этап: Быстрое продвижение по массиву большими шагами
    prev = 0                 # Текущая стартовая точка
    while arr[min(step, n)-1] < target:
        prev = step           # Запоминаем предыдущий шаг
        step += int(math.sqrt(n))  # Увеличение шага
        if prev >= n:         # Если вышли за пределы массива
            return -1         # Целевого элемента нет
    
    # 2-й этап: Обычный линейный поиск в маленькой окрестности
    for i in range(prev, min(step, n)):
        if arr[i] == target:  # Если нашли элемент
            return i          # Возвращаем его индекс
    
    return -1                # Если элемент не найден

# Пример использования
if __name__ == "__main__":
    arr = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
    target = 13
    result = jump_search(arr, target)
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}.")
    else:
        print(f"Элемент {target} не найден в массиве.")

экспоненциальный поиск
def binary_search(arr, left, right, target):
    """
    Вспомогательная функция бинарного поиска.
    """
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    """
    Реализация экспоненциального поиска.
    """
    n = len(arr)
    if arr[0] == target:
        return 0  # Специальный случай: первое совпадение прямо на старте
    
    # Экспоненциальное увеличение шага, пока не выйдем за рамки массива или не превысим цель
    i = 1
    while i < n and arr[i] <= target:
        i *= 2
    
    # Диапазон определен: от последнего известного хорошего места до ближайшего меньшего экспоненциального шага
    left = i // 2
    right = min(i, n - 1)
    
    # Применяем бинарный поиск в найденном диапазоне
    return binary_search(arr, left, right, target)

# Пример использования
if __name__ == "__main__":
    arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    target = 11
    result = exponential_search(arr, target)
    if result != -1:
        print(f"Элемент {target} найден на позиции {result}.")
    else:
        print(f"Элемент {target} не найден в массиве.")

arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target = 11
Элемент 11 найден на позиции 5.
